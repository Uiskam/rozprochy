# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `smarthome.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module smarthome
_M_smarthome = Ice.openModule('smarthome')
__name__ = 'smarthome'

if 'InvalidInput' not in _M_smarthome.__dict__:
    _M_smarthome.InvalidInput = Ice.createTempClass()
    class InvalidInput(Ice.UserException):
        def __init__(self, message=''):
            self.message = message

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::smarthome::InvalidInput'

    _M_smarthome._t_InvalidInput = IcePy.defineException('::smarthome::InvalidInput', InvalidInput, (), False, None, (('message', (), IcePy._t_string, False, 0),))
    InvalidInput._ice_type = _M_smarthome._t_InvalidInput

    _M_smarthome.InvalidInput = InvalidInput
    del InvalidInput

if 'DayOfTheWeek' not in _M_smarthome.__dict__:
    _M_smarthome.DayOfTheWeek = Ice.createTempClass()
    class DayOfTheWeek(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    DayOfTheWeek.MON = DayOfTheWeek("MON", 0)
    DayOfTheWeek.TUE = DayOfTheWeek("TUE", 1)
    DayOfTheWeek.WED = DayOfTheWeek("WED", 2)
    DayOfTheWeek.THU = DayOfTheWeek("THU", 3)
    DayOfTheWeek.FRI = DayOfTheWeek("FRI", 4)
    DayOfTheWeek.SAT = DayOfTheWeek("SAT", 5)
    DayOfTheWeek.SUN = DayOfTheWeek("SUN", 6)
    DayOfTheWeek._enumerators = { 0:DayOfTheWeek.MON, 1:DayOfTheWeek.TUE, 2:DayOfTheWeek.WED, 3:DayOfTheWeek.THU, 4:DayOfTheWeek.FRI, 5:DayOfTheWeek.SAT, 6:DayOfTheWeek.SUN }

    _M_smarthome._t_DayOfTheWeek = IcePy.defineEnum('::smarthome::DayOfTheWeek', DayOfTheWeek, (), DayOfTheWeek._enumerators)

    _M_smarthome.DayOfTheWeek = DayOfTheWeek
    del DayOfTheWeek

if 'WorkMode' not in _M_smarthome.__dict__:
    _M_smarthome.WorkMode = Ice.createTempClass()
    class WorkMode(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    WorkMode.ON = WorkMode("ON", 0)
    WorkMode.OFF = WorkMode("OFF", 1)
    WorkMode.PROGRAM = WorkMode("PROGRAM", 2)
    WorkMode._enumerators = { 0:WorkMode.ON, 1:WorkMode.OFF, 2:WorkMode.PROGRAM }

    _M_smarthome._t_WorkMode = IcePy.defineEnum('::smarthome::WorkMode', WorkMode, (), WorkMode._enumerators)

    _M_smarthome.WorkMode = WorkMode
    del WorkMode

if 'WorkTimeInterval' not in _M_smarthome.__dict__:
    _M_smarthome.WorkTimeInterval = Ice.createTempClass()
    class WorkTimeInterval(object):
        def __init__(self, beginWork='', endWork=''):
            self.beginWork = beginWork
            self.endWork = endWork

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.beginWork)
            _h = 5 * _h + Ice.getHash(self.endWork)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_smarthome.WorkTimeInterval):
                return NotImplemented
            else:
                if self.beginWork is None or other.beginWork is None:
                    if self.beginWork != other.beginWork:
                        return (-1 if self.beginWork is None else 1)
                else:
                    if self.beginWork < other.beginWork:
                        return -1
                    elif self.beginWork > other.beginWork:
                        return 1
                if self.endWork is None or other.endWork is None:
                    if self.endWork != other.endWork:
                        return (-1 if self.endWork is None else 1)
                else:
                    if self.endWork < other.endWork:
                        return -1
                    elif self.endWork > other.endWork:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_WorkTimeInterval)

        __repr__ = __str__

    _M_smarthome._t_WorkTimeInterval = IcePy.defineStruct('::smarthome::WorkTimeInterval', WorkTimeInterval, (), (
        ('beginWork', (), IcePy._t_string),
        ('endWork', (), IcePy._t_string)
    ))

    _M_smarthome.WorkTimeInterval = WorkTimeInterval
    del WorkTimeInterval

_M_smarthome._t_ProgrammableDevice = IcePy.defineValue('::smarthome::ProgrammableDevice', Ice.Value, -1, (), False, True, None, ())

if 'ProgrammableDevicePrx' not in _M_smarthome.__dict__:
    _M_smarthome.ProgrammableDevicePrx = Ice.createTempClass()
    class ProgrammableDevicePrx(Ice.ObjectPrx):

        def getWorkMode(self, context=None):
            return _M_smarthome.ProgrammableDevice._op_getWorkMode.invoke(self, ((), context))

        def getWorkModeAsync(self, context=None):
            return _M_smarthome.ProgrammableDevice._op_getWorkMode.invokeAsync(self, ((), context))

        def begin_getWorkMode(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.ProgrammableDevice._op_getWorkMode.begin(self, ((), _response, _ex, _sent, context))

        def end_getWorkMode(self, _r):
            return _M_smarthome.ProgrammableDevice._op_getWorkMode.end(self, _r)

        def setWorkMode(self, state, context=None):
            return _M_smarthome.ProgrammableDevice._op_setWorkMode.invoke(self, ((state, ), context))

        def setWorkModeAsync(self, state, context=None):
            return _M_smarthome.ProgrammableDevice._op_setWorkMode.invokeAsync(self, ((state, ), context))

        def begin_setWorkMode(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.ProgrammableDevice._op_setWorkMode.begin(self, ((state, ), _response, _ex, _sent, context))

        def end_setWorkMode(self, _r):
            return _M_smarthome.ProgrammableDevice._op_setWorkMode.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_smarthome.ProgrammableDevicePrx.ice_checkedCast(proxy, '::smarthome::ProgrammableDevice', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_smarthome.ProgrammableDevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::smarthome::ProgrammableDevice'
    _M_smarthome._t_ProgrammableDevicePrx = IcePy.defineProxy('::smarthome::ProgrammableDevice', ProgrammableDevicePrx)

    _M_smarthome.ProgrammableDevicePrx = ProgrammableDevicePrx
    del ProgrammableDevicePrx

    _M_smarthome.ProgrammableDevice = Ice.createTempClass()
    class ProgrammableDevice(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::smarthome::ProgrammableDevice')

        def ice_id(self, current=None):
            return '::smarthome::ProgrammableDevice'

        @staticmethod
        def ice_staticId():
            return '::smarthome::ProgrammableDevice'

        def getWorkMode(self, current=None):
            raise NotImplementedError("servant method 'getWorkMode' not implemented")

        def setWorkMode(self, state, current=None):
            raise NotImplementedError("servant method 'setWorkMode' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_ProgrammableDeviceDisp)

        __repr__ = __str__

    _M_smarthome._t_ProgrammableDeviceDisp = IcePy.defineClass('::smarthome::ProgrammableDevice', ProgrammableDevice, (), None, ())
    ProgrammableDevice._ice_type = _M_smarthome._t_ProgrammableDeviceDisp

    ProgrammableDevice._op_getWorkMode = IcePy.Operation('getWorkMode', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_smarthome._t_WorkMode, False, 0), ())
    ProgrammableDevice._op_setWorkMode = IcePy.Operation('setWorkMode', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_smarthome._t_WorkMode, False, 0),), (), None, ())

    _M_smarthome.ProgrammableDevice = ProgrammableDevice
    del ProgrammableDevice

if '_t_WorkTime' not in _M_smarthome.__dict__:
    _M_smarthome._t_WorkTime = IcePy.defineDictionary('::smarthome::WorkTime', (), _M_smarthome._t_DayOfTheWeek, _M_smarthome._t_WorkTimeInterval)

_M_smarthome._t_SchedulableDevice = IcePy.defineValue('::smarthome::SchedulableDevice', Ice.Value, -1, (), False, True, None, ())

if 'SchedulableDevicePrx' not in _M_smarthome.__dict__:
    _M_smarthome.SchedulableDevicePrx = Ice.createTempClass()
    class SchedulableDevicePrx(_M_smarthome.ProgrammableDevicePrx):

        def setWorkSchedule(self, day, time, context=None):
            return _M_smarthome.SchedulableDevice._op_setWorkSchedule.invoke(self, ((day, time), context))

        def setWorkScheduleAsync(self, day, time, context=None):
            return _M_smarthome.SchedulableDevice._op_setWorkSchedule.invokeAsync(self, ((day, time), context))

        def begin_setWorkSchedule(self, day, time, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.SchedulableDevice._op_setWorkSchedule.begin(self, ((day, time), _response, _ex, _sent, context))

        def end_setWorkSchedule(self, _r):
            return _M_smarthome.SchedulableDevice._op_setWorkSchedule.end(self, _r)

        def getWorkSchedule(self, day, context=None):
            return _M_smarthome.SchedulableDevice._op_getWorkSchedule.invoke(self, ((day, ), context))

        def getWorkScheduleAsync(self, day, context=None):
            return _M_smarthome.SchedulableDevice._op_getWorkSchedule.invokeAsync(self, ((day, ), context))

        def begin_getWorkSchedule(self, day, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.SchedulableDevice._op_getWorkSchedule.begin(self, ((day, ), _response, _ex, _sent, context))

        def end_getWorkSchedule(self, _r):
            return _M_smarthome.SchedulableDevice._op_getWorkSchedule.end(self, _r)

        def clearWorkSchedule(self, day, context=None):
            return _M_smarthome.SchedulableDevice._op_clearWorkSchedule.invoke(self, ((day, ), context))

        def clearWorkScheduleAsync(self, day, context=None):
            return _M_smarthome.SchedulableDevice._op_clearWorkSchedule.invokeAsync(self, ((day, ), context))

        def begin_clearWorkSchedule(self, day, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.SchedulableDevice._op_clearWorkSchedule.begin(self, ((day, ), _response, _ex, _sent, context))

        def end_clearWorkSchedule(self, _r):
            return _M_smarthome.SchedulableDevice._op_clearWorkSchedule.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_smarthome.SchedulableDevicePrx.ice_checkedCast(proxy, '::smarthome::SchedulableDevice', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_smarthome.SchedulableDevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::smarthome::SchedulableDevice'
    _M_smarthome._t_SchedulableDevicePrx = IcePy.defineProxy('::smarthome::SchedulableDevice', SchedulableDevicePrx)

    _M_smarthome.SchedulableDevicePrx = SchedulableDevicePrx
    del SchedulableDevicePrx

    _M_smarthome.SchedulableDevice = Ice.createTempClass()
    class SchedulableDevice(_M_smarthome.ProgrammableDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::smarthome::ProgrammableDevice', '::smarthome::SchedulableDevice')

        def ice_id(self, current=None):
            return '::smarthome::SchedulableDevice'

        @staticmethod
        def ice_staticId():
            return '::smarthome::SchedulableDevice'

        def setWorkSchedule(self, day, time, current=None):
            raise NotImplementedError("servant method 'setWorkSchedule' not implemented")

        def getWorkSchedule(self, day, current=None):
            raise NotImplementedError("servant method 'getWorkSchedule' not implemented")

        def clearWorkSchedule(self, day, current=None):
            raise NotImplementedError("servant method 'clearWorkSchedule' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_SchedulableDeviceDisp)

        __repr__ = __str__

    _M_smarthome._t_SchedulableDeviceDisp = IcePy.defineClass('::smarthome::SchedulableDevice', SchedulableDevice, (), None, (_M_smarthome._t_ProgrammableDeviceDisp,))
    SchedulableDevice._ice_type = _M_smarthome._t_SchedulableDeviceDisp

    SchedulableDevice._op_setWorkSchedule = IcePy.Operation('setWorkSchedule', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_smarthome._t_DayOfTheWeek, False, 0), ((), _M_smarthome._t_WorkTimeInterval, False, 0)), (), None, (_M_smarthome._t_InvalidInput,))
    SchedulableDevice._op_getWorkSchedule = IcePy.Operation('getWorkSchedule', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_smarthome._t_DayOfTheWeek, False, 0),), (), ((), _M_smarthome._t_WorkTime, False, 0), ())
    SchedulableDevice._op_clearWorkSchedule = IcePy.Operation('clearWorkSchedule', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_smarthome._t_DayOfTheWeek, False, 0),), (), None, ())

    _M_smarthome.SchedulableDevice = SchedulableDevice
    del SchedulableDevice

_M_smarthome._t_AdvancedHeater = IcePy.defineValue('::smarthome::AdvancedHeater', Ice.Value, -1, (), False, True, None, ())

if 'AdvancedHeaterPrx' not in _M_smarthome.__dict__:
    _M_smarthome.AdvancedHeaterPrx = Ice.createTempClass()
    class AdvancedHeaterPrx(_M_smarthome.ProgrammableDevicePrx):

        def setTemperature(self, temp, context=None):
            return _M_smarthome.AdvancedHeater._op_setTemperature.invoke(self, ((temp, ), context))

        def setTemperatureAsync(self, temp, context=None):
            return _M_smarthome.AdvancedHeater._op_setTemperature.invokeAsync(self, ((temp, ), context))

        def begin_setTemperature(self, temp, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.AdvancedHeater._op_setTemperature.begin(self, ((temp, ), _response, _ex, _sent, context))

        def end_setTemperature(self, _r):
            return _M_smarthome.AdvancedHeater._op_setTemperature.end(self, _r)

        def getTemperature(self, context=None):
            return _M_smarthome.AdvancedHeater._op_getTemperature.invoke(self, ((), context))

        def getTemperatureAsync(self, context=None):
            return _M_smarthome.AdvancedHeater._op_getTemperature.invokeAsync(self, ((), context))

        def begin_getTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.AdvancedHeater._op_getTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getTemperature(self, _r):
            return _M_smarthome.AdvancedHeater._op_getTemperature.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_smarthome.AdvancedHeaterPrx.ice_checkedCast(proxy, '::smarthome::AdvancedHeater', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_smarthome.AdvancedHeaterPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::smarthome::AdvancedHeater'
    _M_smarthome._t_AdvancedHeaterPrx = IcePy.defineProxy('::smarthome::AdvancedHeater', AdvancedHeaterPrx)

    _M_smarthome.AdvancedHeaterPrx = AdvancedHeaterPrx
    del AdvancedHeaterPrx

    _M_smarthome.AdvancedHeater = Ice.createTempClass()
    class AdvancedHeater(_M_smarthome.ProgrammableDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::smarthome::AdvancedHeater', '::smarthome::ProgrammableDevice')

        def ice_id(self, current=None):
            return '::smarthome::AdvancedHeater'

        @staticmethod
        def ice_staticId():
            return '::smarthome::AdvancedHeater'

        def setTemperature(self, temp, current=None):
            raise NotImplementedError("servant method 'setTemperature' not implemented")

        def getTemperature(self, current=None):
            raise NotImplementedError("servant method 'getTemperature' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_AdvancedHeaterDisp)

        __repr__ = __str__

    _M_smarthome._t_AdvancedHeaterDisp = IcePy.defineClass('::smarthome::AdvancedHeater', AdvancedHeater, (), None, (_M_smarthome._t_ProgrammableDeviceDisp,))
    AdvancedHeater._ice_type = _M_smarthome._t_AdvancedHeaterDisp

    AdvancedHeater._op_setTemperature = IcePy.Operation('setTemperature', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_smarthome._t_InvalidInput,))
    AdvancedHeater._op_getTemperature = IcePy.Operation('getTemperature', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())

    _M_smarthome.AdvancedHeater = AdvancedHeater
    del AdvancedHeater

if 'Color' not in _M_smarthome.__dict__:
    _M_smarthome.Color = Ice.createTempClass()
    class Color(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Color.RED = Color("RED", 0)
    Color.GREEN = Color("GREEN", 1)
    Color.BLUE = Color("BLUE", 2)
    Color.YELLOW = Color("YELLOW", 3)
    Color.WHITE = Color("WHITE", 4)
    Color.ORANGE = Color("ORANGE", 5)
    Color.PURPLE = Color("PURPLE", 6)
    Color.PINK = Color("PINK", 7)
    Color.CYAN = Color("CYAN", 8)
    Color.BLACK = Color("BLACK", 9)
    Color._enumerators = { 0:Color.RED, 1:Color.GREEN, 2:Color.BLUE, 3:Color.YELLOW, 4:Color.WHITE, 5:Color.ORANGE, 6:Color.PURPLE, 7:Color.PINK, 8:Color.CYAN, 9:Color.BLACK }

    _M_smarthome._t_Color = IcePy.defineEnum('::smarthome::Color', Color, (), Color._enumerators)

    _M_smarthome.Color = Color
    del Color

if 'LightStatus' not in _M_smarthome.__dict__:
    _M_smarthome.LightStatus = Ice.createTempClass()
    class LightStatus(object):
        def __init__(self, brightness=0, color=_M_smarthome.Color.RED):
            self.brightness = brightness
            self.color = color

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.brightness)
            _h = 5 * _h + Ice.getHash(self.color)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_smarthome.LightStatus):
                return NotImplemented
            else:
                if self.brightness is None or other.brightness is None:
                    if self.brightness != other.brightness:
                        return (-1 if self.brightness is None else 1)
                else:
                    if self.brightness < other.brightness:
                        return -1
                    elif self.brightness > other.brightness:
                        return 1
                if self.color is None or other.color is None:
                    if self.color != other.color:
                        return (-1 if self.color is None else 1)
                else:
                    if self.color < other.color:
                        return -1
                    elif self.color > other.color:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_LightStatus)

        __repr__ = __str__

    _M_smarthome._t_LightStatus = IcePy.defineStruct('::smarthome::LightStatus', LightStatus, (), (
        ('brightness', (), IcePy._t_int),
        ('color', (), _M_smarthome._t_Color)
    ))

    _M_smarthome.LightStatus = LightStatus
    del LightStatus

_M_smarthome._t_Light = IcePy.defineValue('::smarthome::Light', Ice.Value, -1, (), False, True, None, ())

if 'LightPrx' not in _M_smarthome.__dict__:
    _M_smarthome.LightPrx = Ice.createTempClass()
    class LightPrx(_M_smarthome.SchedulableDevicePrx):

        def setStatus(self, settings, context=None):
            return _M_smarthome.Light._op_setStatus.invoke(self, ((settings, ), context))

        def setStatusAsync(self, settings, context=None):
            return _M_smarthome.Light._op_setStatus.invokeAsync(self, ((settings, ), context))

        def begin_setStatus(self, settings, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Light._op_setStatus.begin(self, ((settings, ), _response, _ex, _sent, context))

        def end_setStatus(self, _r):
            return _M_smarthome.Light._op_setStatus.end(self, _r)

        def getStatus(self, context=None):
            return _M_smarthome.Light._op_getStatus.invoke(self, ((), context))

        def getStatusAsync(self, context=None):
            return _M_smarthome.Light._op_getStatus.invokeAsync(self, ((), context))

        def begin_getStatus(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Light._op_getStatus.begin(self, ((), _response, _ex, _sent, context))

        def end_getStatus(self, _r):
            return _M_smarthome.Light._op_getStatus.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_smarthome.LightPrx.ice_checkedCast(proxy, '::smarthome::Light', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_smarthome.LightPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::smarthome::Light'
    _M_smarthome._t_LightPrx = IcePy.defineProxy('::smarthome::Light', LightPrx)

    _M_smarthome.LightPrx = LightPrx
    del LightPrx

    _M_smarthome.Light = Ice.createTempClass()
    class Light(_M_smarthome.SchedulableDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::smarthome::Light', '::smarthome::ProgrammableDevice', '::smarthome::SchedulableDevice')

        def ice_id(self, current=None):
            return '::smarthome::Light'

        @staticmethod
        def ice_staticId():
            return '::smarthome::Light'

        def setStatus(self, settings, current=None):
            raise NotImplementedError("servant method 'setStatus' not implemented")

        def getStatus(self, current=None):
            raise NotImplementedError("servant method 'getStatus' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_LightDisp)

        __repr__ = __str__

    _M_smarthome._t_LightDisp = IcePy.defineClass('::smarthome::Light', Light, (), None, (_M_smarthome._t_SchedulableDeviceDisp,))
    Light._ice_type = _M_smarthome._t_LightDisp

    Light._op_setStatus = IcePy.Operation('setStatus', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_smarthome._t_LightStatus, False, 0),), (), None, (_M_smarthome._t_InvalidInput,))
    Light._op_getStatus = IcePy.Operation('getStatus', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_smarthome._t_LightStatus, False, 0), ())

    _M_smarthome.Light = Light
    del Light

if 'Pattern' not in _M_smarthome.__dict__:
    _M_smarthome.Pattern = Ice.createTempClass()
    class Pattern(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Pattern.BLINK = Pattern("BLINK", 0)
    Pattern.FADE = Pattern("FADE", 1)
    Pattern.RANDOM = Pattern("RANDOM", 2)
    Pattern._enumerators = { 0:Pattern.BLINK, 1:Pattern.FADE, 2:Pattern.RANDOM }

    _M_smarthome._t_Pattern = IcePy.defineEnum('::smarthome::Pattern', Pattern, (), Pattern._enumerators)

    _M_smarthome.Pattern = Pattern
    del Pattern

_M_smarthome._t_DecorativeLight = IcePy.defineValue('::smarthome::DecorativeLight', Ice.Value, -1, (), False, True, None, ())

if 'DecorativeLightPrx' not in _M_smarthome.__dict__:
    _M_smarthome.DecorativeLightPrx = Ice.createTempClass()
    class DecorativeLightPrx(_M_smarthome.LightPrx):

        def setPattern(self, pattern, context=None):
            return _M_smarthome.DecorativeLight._op_setPattern.invoke(self, ((pattern, ), context))

        def setPatternAsync(self, pattern, context=None):
            return _M_smarthome.DecorativeLight._op_setPattern.invokeAsync(self, ((pattern, ), context))

        def begin_setPattern(self, pattern, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.DecorativeLight._op_setPattern.begin(self, ((pattern, ), _response, _ex, _sent, context))

        def end_setPattern(self, _r):
            return _M_smarthome.DecorativeLight._op_setPattern.end(self, _r)

        def getPattern(self, context=None):
            return _M_smarthome.DecorativeLight._op_getPattern.invoke(self, ((), context))

        def getPatternAsync(self, context=None):
            return _M_smarthome.DecorativeLight._op_getPattern.invokeAsync(self, ((), context))

        def begin_getPattern(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.DecorativeLight._op_getPattern.begin(self, ((), _response, _ex, _sent, context))

        def end_getPattern(self, _r):
            return _M_smarthome.DecorativeLight._op_getPattern.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_smarthome.DecorativeLightPrx.ice_checkedCast(proxy, '::smarthome::DecorativeLight', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_smarthome.DecorativeLightPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::smarthome::DecorativeLight'
    _M_smarthome._t_DecorativeLightPrx = IcePy.defineProxy('::smarthome::DecorativeLight', DecorativeLightPrx)

    _M_smarthome.DecorativeLightPrx = DecorativeLightPrx
    del DecorativeLightPrx

    _M_smarthome.DecorativeLight = Ice.createTempClass()
    class DecorativeLight(_M_smarthome.Light):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::smarthome::DecorativeLight', '::smarthome::Light', '::smarthome::ProgrammableDevice', '::smarthome::SchedulableDevice')

        def ice_id(self, current=None):
            return '::smarthome::DecorativeLight'

        @staticmethod
        def ice_staticId():
            return '::smarthome::DecorativeLight'

        def setPattern(self, pattern, current=None):
            raise NotImplementedError("servant method 'setPattern' not implemented")

        def getPattern(self, current=None):
            raise NotImplementedError("servant method 'getPattern' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_DecorativeLightDisp)

        __repr__ = __str__

    _M_smarthome._t_DecorativeLightDisp = IcePy.defineClass('::smarthome::DecorativeLight', DecorativeLight, (), None, (_M_smarthome._t_LightDisp,))
    DecorativeLight._ice_type = _M_smarthome._t_DecorativeLightDisp

    DecorativeLight._op_setPattern = IcePy.Operation('setPattern', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_smarthome._t_Pattern, False, 0),), (), None, (_M_smarthome._t_InvalidInput,))
    DecorativeLight._op_getPattern = IcePy.Operation('getPattern', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_smarthome._t_Pattern, False, 0), ())

    _M_smarthome.DecorativeLight = DecorativeLight
    del DecorativeLight

if 'GroceriesItem' not in _M_smarthome.__dict__:
    _M_smarthome.GroceriesItem = Ice.createTempClass()
    class GroceriesItem(object):
        def __init__(self, name='', quantity=''):
            self.name = name
            self.quantity = quantity

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.quantity)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_smarthome.GroceriesItem):
                return NotImplemented
            else:
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.quantity is None or other.quantity is None:
                    if self.quantity != other.quantity:
                        return (-1 if self.quantity is None else 1)
                else:
                    if self.quantity < other.quantity:
                        return -1
                    elif self.quantity > other.quantity:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_GroceriesItem)

        __repr__ = __str__

    _M_smarthome._t_GroceriesItem = IcePy.defineStruct('::smarthome::GroceriesItem', GroceriesItem, (), (
        ('name', (), IcePy._t_string),
        ('quantity', (), IcePy._t_string)
    ))

    _M_smarthome.GroceriesItem = GroceriesItem
    del GroceriesItem

if 'FridgeStatus' not in _M_smarthome.__dict__:
    _M_smarthome.FridgeStatus = Ice.createTempClass()
    class FridgeStatus(object):
        def __init__(self, temperature=0, humidity=0, doorClosed=False):
            self.temperature = temperature
            self.humidity = humidity
            self.doorClosed = doorClosed

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.temperature)
            _h = 5 * _h + Ice.getHash(self.humidity)
            _h = 5 * _h + Ice.getHash(self.doorClosed)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_smarthome.FridgeStatus):
                return NotImplemented
            else:
                if self.temperature is None or other.temperature is None:
                    if self.temperature != other.temperature:
                        return (-1 if self.temperature is None else 1)
                else:
                    if self.temperature < other.temperature:
                        return -1
                    elif self.temperature > other.temperature:
                        return 1
                if self.humidity is None or other.humidity is None:
                    if self.humidity != other.humidity:
                        return (-1 if self.humidity is None else 1)
                else:
                    if self.humidity < other.humidity:
                        return -1
                    elif self.humidity > other.humidity:
                        return 1
                if self.doorClosed is None or other.doorClosed is None:
                    if self.doorClosed != other.doorClosed:
                        return (-1 if self.doorClosed is None else 1)
                else:
                    if self.doorClosed < other.doorClosed:
                        return -1
                    elif self.doorClosed > other.doorClosed:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_FridgeStatus)

        __repr__ = __str__

    _M_smarthome._t_FridgeStatus = IcePy.defineStruct('::smarthome::FridgeStatus', FridgeStatus, (), (
        ('temperature', (), IcePy._t_int),
        ('humidity', (), IcePy._t_int),
        ('doorClosed', (), IcePy._t_bool)
    ))

    _M_smarthome.FridgeStatus = FridgeStatus
    del FridgeStatus

if '_t_GroceriesList' not in _M_smarthome.__dict__:
    _M_smarthome._t_GroceriesList = IcePy.defineSequence('::smarthome::GroceriesList', (), _M_smarthome._t_GroceriesItem)

_M_smarthome._t_Fridge = IcePy.defineValue('::smarthome::Fridge', Ice.Value, -1, (), False, True, None, ())

if 'FridgePrx' not in _M_smarthome.__dict__:
    _M_smarthome.FridgePrx = Ice.createTempClass()
    class FridgePrx(Ice.ObjectPrx):

        def getStatus(self, context=None):
            return _M_smarthome.Fridge._op_getStatus.invoke(self, ((), context))

        def getStatusAsync(self, context=None):
            return _M_smarthome.Fridge._op_getStatus.invokeAsync(self, ((), context))

        def begin_getStatus(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Fridge._op_getStatus.begin(self, ((), _response, _ex, _sent, context))

        def end_getStatus(self, _r):
            return _M_smarthome.Fridge._op_getStatus.end(self, _r)

        def setStatus(self, FridgeStatus, context=None):
            return _M_smarthome.Fridge._op_setStatus.invoke(self, ((FridgeStatus, ), context))

        def setStatusAsync(self, FridgeStatus, context=None):
            return _M_smarthome.Fridge._op_setStatus.invokeAsync(self, ((FridgeStatus, ), context))

        def begin_setStatus(self, FridgeStatus, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Fridge._op_setStatus.begin(self, ((FridgeStatus, ), _response, _ex, _sent, context))

        def end_setStatus(self, _r):
            return _M_smarthome.Fridge._op_setStatus.end(self, _r)

        def addGroceriesItem(self, GroceriesList, context=None):
            return _M_smarthome.Fridge._op_addGroceriesItem.invoke(self, ((GroceriesList, ), context))

        def addGroceriesItemAsync(self, GroceriesList, context=None):
            return _M_smarthome.Fridge._op_addGroceriesItem.invokeAsync(self, ((GroceriesList, ), context))

        def begin_addGroceriesItem(self, GroceriesList, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Fridge._op_addGroceriesItem.begin(self, ((GroceriesList, ), _response, _ex, _sent, context))

        def end_addGroceriesItem(self, _r):
            return _M_smarthome.Fridge._op_addGroceriesItem.end(self, _r)

        def getGroceries(self, context=None):
            return _M_smarthome.Fridge._op_getGroceries.invoke(self, ((), context))

        def getGroceriesAsync(self, context=None):
            return _M_smarthome.Fridge._op_getGroceries.invokeAsync(self, ((), context))

        def begin_getGroceries(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Fridge._op_getGroceries.begin(self, ((), _response, _ex, _sent, context))

        def end_getGroceries(self, _r):
            return _M_smarthome.Fridge._op_getGroceries.end(self, _r)

        def removeGroceriesItem(self, name, context=None):
            return _M_smarthome.Fridge._op_removeGroceriesItem.invoke(self, ((name, ), context))

        def removeGroceriesItemAsync(self, name, context=None):
            return _M_smarthome.Fridge._op_removeGroceriesItem.invokeAsync(self, ((name, ), context))

        def begin_removeGroceriesItem(self, name, _response=None, _ex=None, _sent=None, context=None):
            return _M_smarthome.Fridge._op_removeGroceriesItem.begin(self, ((name, ), _response, _ex, _sent, context))

        def end_removeGroceriesItem(self, _r):
            return _M_smarthome.Fridge._op_removeGroceriesItem.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_smarthome.FridgePrx.ice_checkedCast(proxy, '::smarthome::Fridge', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_smarthome.FridgePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::smarthome::Fridge'
    _M_smarthome._t_FridgePrx = IcePy.defineProxy('::smarthome::Fridge', FridgePrx)

    _M_smarthome.FridgePrx = FridgePrx
    del FridgePrx

    _M_smarthome.Fridge = Ice.createTempClass()
    class Fridge(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::smarthome::Fridge')

        def ice_id(self, current=None):
            return '::smarthome::Fridge'

        @staticmethod
        def ice_staticId():
            return '::smarthome::Fridge'

        def getStatus(self, current=None):
            raise NotImplementedError("servant method 'getStatus' not implemented")

        def setStatus(self, FridgeStatus, current=None):
            raise NotImplementedError("servant method 'setStatus' not implemented")

        def addGroceriesItem(self, GroceriesList, current=None):
            raise NotImplementedError("servant method 'addGroceriesItem' not implemented")

        def getGroceries(self, current=None):
            raise NotImplementedError("servant method 'getGroceries' not implemented")

        def removeGroceriesItem(self, name, current=None):
            raise NotImplementedError("servant method 'removeGroceriesItem' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_smarthome._t_FridgeDisp)

        __repr__ = __str__

    _M_smarthome._t_FridgeDisp = IcePy.defineClass('::smarthome::Fridge', Fridge, (), None, ())
    Fridge._ice_type = _M_smarthome._t_FridgeDisp

    Fridge._op_getStatus = IcePy.Operation('getStatus', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_smarthome._t_FridgeStatus, False, 0), ())
    Fridge._op_setStatus = IcePy.Operation('setStatus', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_smarthome._t_FridgeStatus, False, 0),), (), None, (_M_smarthome._t_InvalidInput,))
    Fridge._op_addGroceriesItem = IcePy.Operation('addGroceriesItem', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_smarthome._t_GroceriesItem, False, 0),), (), None, (_M_smarthome._t_InvalidInput,))
    Fridge._op_getGroceries = IcePy.Operation('getGroceries', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_smarthome._t_GroceriesList, False, 0), ())
    Fridge._op_removeGroceriesItem = IcePy.Operation('removeGroceriesItem', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), None, ())

    _M_smarthome.Fridge = Fridge
    del Fridge

# End of module smarthome
